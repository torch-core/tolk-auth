import "../constants/type"
import "constants/type";
import "messages/emit";

/*
 * The main structure managing the authority data, including owner and permission dictionaries.
 * The system supports up to 256 distinct roles in total, represented as bits in a RoleMask (uint256).
 * Each role ID corresponds to a bit position in the RoleMask (e.g., role 0 = 1 << 0, role 1 = 1 << 1, etc.).
 * A user's roles or an opcode's allowed roles are encoded as a combined bitmask.
 * For example, roles 1 and 3 result in a RoleMask of 0b00001010 (1 << 1 | 1 << 3).
 * This struct should be included in your contract's storage layout.
 */
struct Auth {
    ownerInfo: OwnerInfo            // Stores ownership data, including current owner, pending owner, and timelock info.
    isCapabilityPublic: map<Opcode, bool>        // Indicates if an opcode is public.
    rolesWithCapability: map<Opcode, RoleMask>       // Maps each opcode to the roles that are allowed to execute it (an opcode can be assigned to multiple roles).
    userRoles: map<address, RoleMask>                 // Dict<address, RoleMask>: Maps user addresses to their assigned roles (a user can have multiple roles).
}

/*
 * Encapsulates ownership transfer information, including timelock parameters.
 */
struct OwnerInfo {
    owner: address                  // Address of the contract owner, who also manages the authority logic.
    pendingOwner: address           // Address of the pending owner, who can claim the ownership after the timelock period.
    timelockPeriod: Timestamp = 0   // Timelock period for the ownership can be claimed.
    proposeTime: Timestamp = 0      // Timestamp of the ownership proposal.
}

/*
 * Retrieves whether a given opcode has public capability.
 * @param self The Auth structure instance.
 * @param opcode The opcode to check.
 * @return True if the opcode has public capability, false otherwise.
 */
@pure
fun Auth.getPublicCapability(self, opcode: Opcode): bool {
    var isPublic = self.isCapabilityPublic.get(opcode);
    return isPublic.isFound ? isPublic.loadValue() : false;
}

/*
 * Retrieves the role mask for a given opcode's capabilities.
 * @param self The Auth structure instance.
 * @param opcode The opcode to check.
 * @return The role mask for the opcode (0 if not found).
 */
@pure
fun Auth.getRoleCapability(self, opcode: Opcode): RoleMask {
    var opRoleMask = self.rolesWithCapability.get(opcode);    
    return (opRoleMask.isFound ? opRoleMask.loadValue() : 0) as RoleMask;
}

/*
 * Retrieves the role mask for a given user.
 * @param self The Auth structure instance.
 * @param user The address of the user to check.
 * @return The role mask for the user (0 if not found).
 */
@pure
fun Auth.getUserRoles(self, user: address): RoleMask {
    var userRoleMask = self.userRoles.get(user);
    return (userRoleMask.isFound ? userRoleMask.loadValue() : 0) as RoleMask;
}

/*
 * Sets the public capability for a given opcode.
 * @param self The mutable Auth structure instance.
 * @param opcode The opcode to set.
 * @param enabled True to enable public capability, false to disable.
 * @dev Emits an TOPIC_PUBLIC_CAPABILITY_UPDATED event after setting the capability.
 */
fun Auth.setPublicCapability(mutate self, opcode: Opcode, enabled: bool) {
    self.isCapabilityPublic.set(opcode, enabled);
    emitPublicCapabilityUpdated(opcode, enabled);
}

/*
 * Sets the capability for a specific role on a given opcode.
 * @param self The mutable Auth structure instance.
 * @param role The role ID to set (0-255).
 * @param opcode The opcode to set the capability for.
 * @param enabled True to enable the role for the opcode, false to disable.
 * @dev Uses bitmask operations to enable/disable the role bit in the capability's role mask.
 *      Emits an TOPIC_ROLE_CAPABILITY_UPDATED event after updating the role capability.
 */
fun Auth.setRoleCapability(mutate self, role: RoleId, opcode: Opcode, enabled: bool) {
    val currentMask = self.getRoleCapability(opcode);
    val newMask = enabled ? (currentMask | 1 << role) : (currentMask & ~(1 << role));
    self.rolesWithCapability.set(opcode, newMask);
    emitRoleCapabilityUpdated(opcode, role, enabled);
}

/*
 * Sets a role for a specific user.
 * @param self The mutable Auth structure instance.
 * @param user The address of the user to update.
 * @param role The role ID to set (0-255).
 * @param enabled True to enable the role for the user, false to disable.
 * @dev Uses bitmask operations to enable/disable the role bit in the user's role mask.
 *      Emits an TOPIC_USER_ROLE_UPDATED event after updating the user's role.
 */
fun Auth.setUserRole(mutate self, user: address, role: RoleId, enabled: bool) {
    val currentMask = self.getUserRoles(user);
    val newMask = enabled ? (currentMask | 1 << role) : (currentMask & ~(1 << role));
    self.userRoles.set(user, newMask);
    emitUserRoleUpdated(user, role, enabled);
}

/*
 * Proposes ownership to a new owner.
 * @param self The mutable Auth structure instance.
 * @param newOwner The address of the new owner.
 * @param proposeTime The timestamp of the ownership proposal.
 * @dev Sets pendingOwner to newOwner
 *      Sets proposeTime
 *      Emits an TOPIC_OWNERSHIP_PROPOSED event after proposing ownership.
 */
fun Auth.proposeOwnership(mutate self, newOwner: address, proposeTime: Timestamp) {
    self.ownerInfo.pendingOwner = newOwner;
    self.ownerInfo.proposeTime = proposeTime;
    emitOwnershipProposed(self.ownerInfo.owner, newOwner, self.ownerInfo.proposeTime, self.ownerInfo.timelockPeriod);
}

/*
 * Clears pending owner information after ownership claim or revocation
 * @param self The mutable Auth structure instance.
 * @dev Resets pendingOwner to none and proposeTime to 0
 */
fun Auth.clearPendingOwner(mutate self) {
    self.ownerInfo.pendingOwner = createAddressNone();
    self.ownerInfo.proposeTime = 0;
}

/*
 * Claims ownership for a new owner.
 * @param self The mutable Auth structure instance.
 * @param newOwner The address of the new owner.
 * @dev Sets owner to newOwner
 *      Resets pendingOwner to none and proposeTime to 0
 *      Emits an TOPIC_OWNERSHIP_CLAIMED event after claiming ownership.
*/
fun Auth.claimOwnership(mutate self, newOwner: address) {
    self.ownerInfo.owner = newOwner;
    self.clearPendingOwner();
    emitOwnershipClaimed(newOwner);
}

/*
 * Revokes pending ownership for a revoker.
 * @param self The mutable Auth structure instance.
 * @param revoker The address of the revoker.
 * @dev Emits an TOPIC_OWNERSHIP_REVOKED event after revoking pending ownership.
 *      Resets pendingOwner to none and proposeTime to 0
 */
fun Auth.revokePendingOwnership(mutate self, revoker: address) {
    // Emit event before clearing pending owner
    emitOwnershipRevoked(revoker, self.ownerInfo.pendingOwner);
    self.clearPendingOwner();
}